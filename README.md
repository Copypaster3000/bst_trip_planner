This program allows users to edit a log of vacations they would like to take in the future. It utilizes a binary search tree to store the data.

Efficiency Writeup

In this program, I used a binary search tree (BST) as the primary data structure. This data structure worked very well for this project. The BST allows a large amount of data to be stored and automatically sorts the data. This feature enabled display in alphabetical order without much compromise. Display of a specific piece of data also requires minimal traversal compared to all the data that is stored. Since BST guarantees an average-case time complexity of O(log n) for fundamental operations such as insertion, deletion, and search, it is particularly effective when dealing with substantial datasets. Because the BST stores data in a sorted order, when traversing the tree each node can be compared to that data being looked for. Then based on that practically half of the tree can be eliminated from possibly holding the data. This is what makes a BST so useful.

Because a sorted display was used in this program, I donâ€™t think any other data structure would have done a better job, except maybe a different kind of tree. A hash table may be able to provide faster access to data on average than a BST, but it does not work well if you need to sort the data. A BST was a perfect solution for this program which worked well even as the dataset grew. The way the tree is shaped, generally it holds more and more data at each level that is added to it so even as more data is added to the tree, its height grows slower and slower. This is good because the height of the BST is ultimately the worst-case scenario there could be for how far a function may have to traverse to get to the data it needs. Therefore, for this specific case, using a BST proved to be the most advantageous option.

An interesting feature of the BST is that its shape changes based on the order of data placed into it. For instance, if data was added in a certain order, like sorted from A to Z, the BST became lopsided, resembling a line more than a tree. This change could slow down data retrieval. Conversely, if the data was added in a more randomized order, the BST maintained a balanced structure, facilitating the basic functions to traverse less, leading to faster operations.

This relationship between the tree's structure and data insertion order can be better understood by assessing the height of the tree in relation to the amount of data it holds. A shorter tree for a given amount of data is desirable because it leads to lower maximum traversal, hence making operations more efficient.

In conclusion, the use of a BST to manage travel destination data proved to be an efficient choice. It enabled the retrieval of information quickly and maintained data in sorted order. While the BST's shape could change based on the data insertion order, adopting the right methods like random insertion maintained its efficiency. This project was a valuable demonstration of the BST's strengths and limitations, which will guide me in choosing the right data structure for future tasks.
